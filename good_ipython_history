 1/1: import odrive
 2/1: import odrive
 2/2: import ODrive_Ease_Lib
 2/3: od = odrive.find_any()
 2/4: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
 2/5: ODrive_Ease_Lib.configure_hoverboard(ax)
 2/6: ax.axis.motor.config.pole_pairs
 2/7: import odrive.enums
 2/8: od.save_configuration()
 2/9: od.reboot()
2/10: od = odrive.find_any()
2/11: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
2/12: ax.axis.requested_state = odrive.enums.AXIS_STATE_MOTOR_CALIBRATION
2/13: ax.axis.motor.config.pre_calibrated = True
2/14: od.save_configuration()
2/15: od.reboot()
2/16: od = odrive.find_any()
2/17: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
2/18: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
2/19: od.reboot()
2/20: od = odrive.find_any()
2/21: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
2/22: ax.axis.encoder.config.use_index = True
2/23: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
2/24: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
2/25: ax.axis.encoder.config.pre_calibrated = True
2/26: od.save_configuration()
2/27: od.reboot()
2/28: od = odrive.find_any()
2/29: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
2/30: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
2/31: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
2/32: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
2/33: ax.axis.motor.config.direction
2/34: ax.axis.motor.config.direction = -1
2/35: ax.index_and_hold(1)
2/36: ax.index_and_hold(1)
2/37: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
2/38: ax.axis.motor.config.direction = -1
2/39: ax.index_and_hold(1)
2/40: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
2/41: ax.index_and_hold(1)
2/42: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
2/43: ax.axis.motor.config.direction = -1
2/44: ax.index_and_hold(1)
2/45: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
2/46: ax.axis.motor.config.direction = -1
2/47: ax.index_and_hold(1)
2/48: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
2/49: ax.axis.motor.config.direction = -1
2/50: ax.index_and_hold(1)
2/51: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
2/52: ax.axis.motor.config.direction = -1
2/53: ax.index_and_hold(1)
2/54: ax.axis.motor.config.direction = -1
2/55: ax.index_and_hold(1)
2/56: ax.axis.motor.config.direction = -1
2/57: ax.index_and_hold(1)
2/58: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
 3/1: import odrive
 3/2: import ODrive_Ease_Lib
 3/3: od = odrive.find_any()
 3/4: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
 3/5: ax.index_and_hold(-1, 1)
 4/1: import odrive
 4/2: import ODrive_Ease_Lib
 4/3: od = odrive.find_any()
 4/4: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
 4/5:
import time
time.sleep(10)
ax.index_and_hold(-1, 1)
 4/6: ax.get_pos()
 4/7: ax.axis.controller.pos_setpoint
 4/8: ax.get_pos_gain()
 4/9: ax.set_pos_gain(2)
4/10: ax.set_pos_gain(3)
4/11: ax.set_pos_gain(5)
4/12: ax.get_curr_limit()
4/13: ax.set_curr_limit(20)
4/14: ax.get_pos()
4/15: ax.set_current(0)
4/16: ax.get_pos()
4/17: ax.set_pos(500)
4/18: ax.set_pos(100)
4/19: ax.set_pos(700)
4/20: ax.set_pos(1000)
4/21: ax.get_pos()
4/22: ax.set_pos(1300)
4/23: ax.set_pos(1500)
4/24: ax.set_pos(100)
4/25: ax.set_pos(1500)
4/26: ax.set_pos(100)
4/27: ax.set_pos(1500)
4/28: ax.set_pos(100)
4/29: ax.set_pos(00)
4/30: ax.set_vel(0)
4/31: ax.set_pos(00)
4/32: ax.set_pos(1500)
4/33: ax.get_pos()
4/34: ax.set_current(0)
 5/1: import odrive
 5/2: import ODrive_Ease_Lib
 5/3: od = odrive.find_any()
 5/4: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
 5/5: ax.index_and_hold(-1, 1)
 5/6: ax.get_pos()
 5/7: ax.set_pos(1400)
 5/8: ax.set_pos_gain(2)
 5/9: ax.set_curr_limit(20)
5/10: ax.set_pos(100)
5/11: ax.set_pos(1400)
5/12: ax.set_pos(100)
5/13: ax.set_pos(1400)
5/14: ax.set_pos(100)
5/15: ax.get_pos()
5/16: ax.set_current(0)
5/17: ax.set_pos(100)
5/18: ax.set_pos(1400)
 6/1: import odrive
 6/2: import ODrive_Ease_Lib
 6/3: od = odrive.find_any()
 6/4: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
 6/5: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
 6/6: ODrive_Ease_Lib.configure_hoverboard(ax)
 6/7: od.save_configuration()
 6/8: od.reboot()
 6/9: od = odrive.find_any()
6/10: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
6/11: import odrive.eums
6/12: import odrive.enums
6/13: ax.axis.requested_state = odrive.enums.AXIS_STATE_MOTOR_CALIBRATION
6/14: ax.axis.motor.error
6/15: ax.axis.motor.config.pre_calibrated = True
6/16: od.save_configuration()
6/17: od.reboot()
6/18: od = odrive.find_any()
6/19: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
6/20: ax.axis.motor.is_calibrated
6/21: ax.axis.encoder.config.use_index = True
6/22: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
6/23: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
6/24: ax.axis.encoder.config.pre_calibrated = True
6/25: od.save_configuration()
6/26: od.reboot()
6/27: od = odrive.find_any()
6/28: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
6/29: ax.axis.encoder.is_ready
6/30: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
6/31: ax.axis.encoder.is_ready
6/32: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
6/33: ax.axis.motor.config.direction
6/34: ax.index_and_hold(-1,1)
6/35: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
6/36: ax.index_and_hold(-1,1)
6/37: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
 7/1: import odrive
 7/2: import odrive.enums
 7/3: import ODrive_Ease_Lib
 7/4: od = odrive.find_any()
 7/5: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
 7/6: ax.index_and_hold(-1,1)
 7/7: ax.axis.error
 7/8: hex(512)
 7/9: od.reboot()
7/10: od = odrive.find_any()
7/11: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
7/12: ax.index_and_hold(-1,1)
7/13: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
7/14: ax.index_and_hold(-1,1)
7/15: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
7/16: od.reboot()
7/17: od = odrive.find_any()
7/18: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
7/19: ax.axis.requested_state = odrive.enums.AXIS_STATE_MOTOR_CALIBRATION
7/20: ax.index_and_hold(-1,1)
7/21: od.reboot()
7/22: od = odrive.find_any()
7/23: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
7/24: ax.axis.motor.config.direction = -1
7/25: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
7/26: ax.set_pos(ax.get_pos())
7/27: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
7/28: ax.axis.motor.config.direction = 1
7/29: ax.set_pos(ax.get_pos())
7/30: od.reboot()
7/31: od = odrive.find_any()
7/32: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
7/33: ax.index_and_hold(-1,1)
7/34: ax.axsi.error
7/35: ax.axis.error
7/36: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
7/37: od.save_configuration()
7/38: od.reboot()
7/39: od = odrive.find_any()
7/40: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
7/41: ax.index_and_hold(-1,1)
7/42: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
7/43: ax.index_and_hold(-1,1)
7/44: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
 8/1: import odrive
 8/2: import ODrive_Ease_Lib
 8/3: import odrive.enums
 8/4: o = ODrive_Ease_Lib.find_ODrives()
 8/5: o
 8/6: len(o)
 8/7: o[0].serial_number
 8/8: o[1].serial_number
 8/9: o[0].axis0.motor.is_calibrated
8/10: o[1].axis0.motor.is_calibrated
8/11: ax = ODrive_Ease_Lib.ODrive_Axis(o[0])
8/12: ax = ODrive_Ease_Lib.ODrive_Axis(o[0].axis0)
8/13: ax
8/14: ax.axis.requested_state = odrive.enums.AXIS_STATE_MOTOR_CALIBRATION
8/15: ax.axis.motor.config.pre_calibrated = True
8/16: o[0].save_configuration()
8/17: o[0].reboot()
8/18: o[1]
8/19: od = odrive.find_any()
8/20: od
8/21: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
8/22: ax.axis.encoder.config.use_index
8/23: ax.axis.encoder.config.use_index = True
8/24: ax.axis.encoder.config.use_index
8/25: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
8/26: ax.axis.error
8/27: ax.axis.requested_state
8/28: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
8/29: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
8/30: ax.axis.requested_state
8/31: odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
8/32: ax.axis.requested_state = 6
8/33: ax.axis.requested_state = 6
8/34: ax.axis.requested_state
8/35: od.reboot()
8/36: od = odrive.find_any()
8/37: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
8/38: ax.axis.motor.is_calibrated
8/39: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
8/40: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
8/41: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
8/42: ax.axis.encoder.error
8/43: ax.axis.encoder.error
8/44: ax.axis.encoder.error = 0
8/45: ax.axis.encoder.error
8/46: ax.axis.error = 0
8/47: ax.axis.error
8/48: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
8/49: ax.axis.error = 0
8/50: ax.axis.encoder.error = 0
8/51: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
8/52: ax.axis.error = 0
8/53: ax.axis.encoder.error
 9/1: import odrive
 9/2: import ODrive_Ease_Lib
10/1: import odrive
10/2: import ODrive_Ease_Lib
11/1: import ODrive_Ease_Lib
11/2: import odrive
11/3: import ordive.enums
11/4: import odrive.enums
11/5: od = odrive.find_any()
11/6: od
11/7: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
11/8: ax.axis.motor.is_calibrated
11/9: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
11/10: ax.axis.encoder.config.use_index = True
11/11: ax.axis.encoder.config.use_index
11/12: ax.axis.requested_state = odrive.enums.AXIS_STATE_MOTOR_CALIBRATION
11/13: ax.axis.motor.is_calibrated
11/14: ax.axis.motor.config.pre_calibrated = True
11/15: od.save_configuration()
11/16: od.reboot()
11/17: od = odrive.find_any()
11/18: od
11/19: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
11/20: ax.axis.motor.is_calibrated
11/21: ax.axis.encoder.config.use_index
11/22: ax.axis.motor.is_calibrated
11/23: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
11/24: ax.axis.error
11/25: ax.axis.encoder.error
11/26: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
11/27: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
11/28: ax.index_and_hold(-1,1)
11/29: ax.axis.eror
11/30: ax.axis.error
11/31: hex(1)
11/32: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
11/33: ax.index_and_hold(-1,1)
11/34: ax.axis.error
11/35: od.reboot()
11/36: od=odrive.find_any()
11/37: od
11/38: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
11/39: ax.axis.motor.is_calibrated
11/40: ax.index_and_hold(-1,1)
11/41: ax.axis.error
11/42: ax.axis.encoder.is_ready
11/43: ax.axis.encoder.config.use_index
11/44: ax.axis.encoder.error
11/45: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
11/46: ax.index_and_hold(-1,1)
11/47: ax.axis.error
11/48: od.save_configuration()
11/49: od.reboot()
11/50: od = odrive.find_any()
11/51: od
11/52: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
11/53: ax.axis.motor.is_calibrated
11/54: ax.axis.encoder.is_ready
11/55: ax.index_and_hold(-1,1)
11/56: ax.axis.enoder.error
11/57: ax.axis.encoder.error
11/58: ax.axis.motor.error
11/59: ax.axis.encoder.is_ready
11/60: ax.axis.encoder.is_ready = True
11/61: ax.axis.motor.is_calibrated
11/62: ax.axis.encoder.config.use_index
11/63: ax.axis.encoder.is_ready
11/64: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
11/65: ax.index_and_hold(-1,1)
11/66: ax.motor.error
11/67: ax.axis.motor.error
11/68: ax.index_and_hold(1,-1)
11/69: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
11/70: ax.axis.motor.is_calibrated
11/71: ax.axis.controller.home_axis()
11/72: ax.axis.controller.home_axis
11/73: ax.axis.controller.home_axis()
11/74: ax.axis.controller.current_setpoint
11/75: ax.axis.controller.move_to_pos(50.0)
11/76: ax.axis.controller.move_to_pos(-50.0)
11/77: ax.axis.controller.pos_setpoint(50)
11/78: ax.axis.controller.pos_setpoint
11/79: ax.axis.controller.pos_setpoint = 50
11/80: ax.axis.controller.move_to_pos()
11/81: ax.axis.controller.move_to_pos(1000)
11/82: ax.axis.controller.pos_setpoint
11/83: ax.axis.controller.pos_setpoint = 1000
11/84: ax.axis.controller.move_to_pos
11/85: ax.axis.motor.error
11/86: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
11/87: ax.axis.requested_state = odrive.enums.CTRL_MODE_POSITION_CONTROL
11/88: ax.axis.controller.current_setpoint
11/89: ax.axis.controller.home_axis
11/90: ax.calibrate()
11/91: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
11/92: ax.index_and_hold(-1, 1)
11/93: ax.axis.error
11/94: hex(257)
11/95: od.reboot()
11/96: od = odrive.find_any()
11/97: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
11/98: ax.axis.motor.iscalibrated()
11/99: ax.axis.motor.is_calibrated
11/100: ax.axis.encoder.is_ready
11/101: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
11/102: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
11/103: ax.axis.error
11/104: ax.axis.motor.error
11/105: ax.axis.encoder.is_ready
11/106: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
11/107: ax.axis.error
11/108: hex(256)
11/109: ax.axis.encoder.is_ready
11/110: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
11/111: od.reboot()
12/1: import odrive
12/2: import ODrive_Ease_Lib
12/3: import odrive.enums
12/4: od = odrive.find_any()
12/5: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
12/6: ax.axis.motor.is_calibrated
12/7: ax.axis.encoder.is_ready
12/8: ax.index_and_hold(-1, 1)
12/9: ax.axis.error
12/10: ax.axis.motor.error
12/11: ax.axis.encoder.error
12/12: ax.axis.error
12/13: hex(512)
12/14: od.reboot()
12/15: od = odrive.find_any()
12/16: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
12/17: ax.axis.motor.is_calibrated
12/18: ax.axis.encoder.is_ready
12/19: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
12/20: ax.axis.error
12/21: hex(256)
12/22: ax.index_and_hold(-1, 1)
12/23: ax.axis.error
12/24: ax.axis.error = 0
12/25: ax.axis.error
12/26: ax.axis.motor.error
12/27: ax.axis.encoder.error
12/28: hex(32)
12/29: ax.axis.encoder.error = 0
12/30: ax.axis.encoder.error
12/31: ax.axis.error
12/32: ax.is_calibrated
12/33: ax.is_calibrated()
12/34: ax.axis.motor.is_calibrated
12/35: ax.axis.encoder.is_ready
12/36: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
12/37: ax.axis.error
12/38: od.reboot()
12/39: od = odrive.find_any()
12/40: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
12/41: ax.axis.encoder.is_ready
12/42: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
12/43: ax.axis.error
12/44: hex(256)
12/45: ax.axis.encoder.config.use_index
13/1: import odrive
13/2: od = odrive.find_any()
13/3: od.reboot()
13/4: od = odrive.find_any()
13/5: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
13/6: import ODrive_Ease_Lib
13/7: import odrive.enums
13/8: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
13/9: ax.axis.motor.is_calibrated
13/10: ax.axis.encoder.is_ready
13/11: ax.axis.requested_state = odrive.enums.AXIS_STATE_MOTOR_CALIBRATION
13/12: ax.axis.error
13/13: ax.axis.encoder.error
13/14: ax.axis.encoder.is_ready
13/15: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
13/16: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_OFFSET_CALIBRATION
13/17: ax.axis.error
13/18: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
13/19: ax.axis.error
13/20: ax.axis.motor.is_calibrated
13/21: ax.axis.encoder.is_ready
13/22: ax.index_and_hold(-1, 1)
13/23: ax.axis.encoder.is_ready
13/24: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
13/25: ax.index_and_hold(-1, 1)
13/26: ax.axis.error
13/27: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis1)
13/28: ax.axis.requested_state = odrive.enums.AXIS_STATE_IDLE
13/29: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
13/30: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
13/31: ax.axis.error = 0
13/32: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
13/33: ax.axis.encoder.index_found
13/34: ax.axis.encoder.vel_estimate
13/35: ax.axis.encoder.vel_estimate
13/36: ax.axis.encoder.vel_estimate
13/37: ax.axis.encoder.pos_estimate
13/38: ax.axis.encoder.pos_estimate
13/39: ax.axis.encoder.pos_estimate
13/40: ax.axis.encoder.pos_estimate
13/41: ax.axis.encoder.pos_estimate
13/42: ax.axis.encoder.pos_estimate
13/43: ax.axis.encoder.pos_estimate
13/44: ax.axis.encoder.error
13/45: hex(32)
13/46: od.reboot
13/47: od.reboot()
14/1: import odrive
14/2: import ODrive_Ease_Lib
14/3: import odrive.enums
14/4: od = odrive.find_any()
14/5: ax = ODrive_Ease_Lib.ODrive_Axis(od.axis0)
14/6: ax.axis.encoder.is_ready
14/7: ax.axis.motor.is_calibrated
14/8: ax.axis.requested_state = odrive.enums.AXIS_STATE_ENCODER_INDEX_SEARCH
14/9: ax.axis.error
14/10: ax.axis.encoder.error
14/11: od.reboot()
   1: %history -g

